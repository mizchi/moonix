// Generated by moon-component
// Import module: wasi:sockets/ip-name-lookup@0.2.9

type ErrorCode = @network.ErrorCode

type IpAddress = @network.IpAddress

///|
pub(all) struct ResolveAddressStream(Int) derive(Show, Eq)

///| Low-level FFI import
fn ffi_resolve_address_stream_resolve_next_address(p0 : Int, retptr : Int) -> Int = "wasi:sockets/ip-name-lookup@0.2.9" "[method]resolve-address-stream.resolve-next-address"

///| High-level wrapper with canonical ABI conversion
pub fn resolve_address_stream_resolve_next_address(handle : ResolveAddressStream) -> Result[IpAddress?, ErrorCode] {
  let retptr = @cabi.cabi_realloc(0, 0, 4, 24)
  let _ = ffi_resolve_address_stream_resolve_next_address(handle.0, retptr)
  match @cabi.cabi_read_i32(retptr) {
    0 => {
      // TODO: lift IpAddress? properly
      Ok(None)
    }
    _ => Err(ErrorCode::from_ordinal(@cabi.cabi_read_i32(retptr + 4)))
  }
}

///| Low-level FFI import
fn ffi_resolve_address_stream_subscribe(p0 : Int) -> Int = "wasi:sockets/ip-name-lookup@0.2.9" "[method]resolve-address-stream.subscribe"

///| High-level wrapper with canonical ABI conversion
pub fn resolve_address_stream_subscribe(handle : ResolveAddressStream) -> @poll.Pollable {
  let result = ffi_resolve_address_stream_subscribe(handle.0)
  @poll.Pollable(result)
}

///| Low-level FFI import
fn ffi_resolve_addresses(p0 : Int, p1_ptr : Int, p1_len : Int, retptr : Int) -> Int = "wasi:sockets/ip-name-lookup@0.2.9" "resolve-addresses"

///| High-level wrapper with canonical ABI conversion
pub fn resolve_addresses(network : @network.Network, name : String) -> Result[ResolveAddressStream, ErrorCode] {
  let (p1_ptr, p1_len) = @cabi.cabi_lower_string(name)
  let retptr = @cabi.cabi_realloc(0, 0, 4, 8)
  let _ = ffi_resolve_addresses(network.0, p1_ptr, p1_len, retptr)
  match @cabi.cabi_read_i32(retptr) {
    0 => Ok(ResolveAddressStream(@cabi.cabi_read_i32(retptr + 4)))
    _ => Err(ErrorCode::from_ordinal(@cabi.cabi_read_i32(retptr + 4)))
  }
}
